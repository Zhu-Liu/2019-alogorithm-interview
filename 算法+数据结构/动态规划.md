目录
---
<!-- TOC -->

- [零钱兑换I](#零钱兑换i)
- [零钱兑换II](#零钱兑换ii)
- [最长公共子序列](#最长公共子序列)
- [最长公共子串](#最长公共子串)
- [最长上升子序列](#最长上升子序列)
- [最长回文子序列](#最长回文子序列)
- [最长回文子串](#最长回文子串)
- [最大连续子序列的和](#最大连续子序列的和)
- [编辑距离](#编辑距离)
- [最大正方形](#最大正方形)

<!-- /TOC -->
## 零钱兑换I
> LeetCode/[零钱兑换I](https://leetcode-cn.com/problems/coin-change/description/)

> bilibili/[花花](https://www.bilibili.com/video/av31621107)

**描述**
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1

输入: coins = [2], amount = 3
输出: -1
```
- INF = amount + 1;
- 初始值令为INF
- dp[i][j]表示使用前i种硬币组成金额j最少需要多少枚
  - dp[i][j] = min{ dp[i][j], dp[i][j-coin[i]] + 1 }
- 空间压缩
  - 则可表示为dp[j] = min{ dp[i-coin] + 1, dp[i]}
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int INF = amount + 1;
        vector<int> dp(amount+1, INF);
        
        dp[0] = 0;
        
        for(auto c : coins)
            for(int i=c;i<=amount;i++)
                dp[i] = min(dp[i], dp[i-c] + 1);
        
        return dp[amount] < INF ? dp[amount] : -1;
    }
};
```

## 零钱兑换II
> LeetCode/[零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)

**描述**
```
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
- dp[j]表示用前i种硬币组成j金额的组合数
- dp[0] = 1，初值为0
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        if(amount<0) return 0;

        vector<int> dp(amount+1, 0);
        dp[0]=1;
        for(auto i: coins)
            for(int j=i;j<=amount;j++)
                    dp[j] += dp[j-i];
        
        return dp[amount];
    }
};
```

## 最长公共子序列
> NowCoder/[最长公共子序列](https://www.nowcoder.com/questionTerminal/c996bbb77dd447d681ec6907ccfb488a)

- dp[i][j]表示两个字符串的最长公共子序列
- 转移方程为
  - 如果A[i - 1] == B[j - 1], dp[i][j] = dp[i-1][j-1] + 1
  - 如果A[i - 1] != B[j - 1], dp[i][j] = max{dp[i-1][j], dp[i][j-1]}
- 注意 dp下标从1开始，可以防止越界
- 为什么相等情况就直接是等号不用取max?
  - 因为dp[i-1][j-1]定义为最长公共子序列，dp[i][j-1]或dp[i-1][j]多出一个字符最多比dp[i-1][j-1]大1，因此可以不用再比较
```c++
class LCS {
public:
    int findLCS(string A, int n, string B, int m) {
        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1; //注意下标
                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        return dp[n][m];
    }
};
```

## 最长公共子串
> NowCoder/[最长公共子串](https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602)

- dp[i][j]表示A[i-1]==B[j-1]时两个子串的最长公共子串
- 返回ret
```c++
class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        int ret=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                if(A[i-1]==B[j-1])
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                    ret = max(ret, dp[i][j]);
                }
        return ret;
    }
};
```

空间复杂度优化成O（N）
```c++
class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
        vector<int>dp(m+1, 0);
        int ret=0;
        for(int i=1;i<=n;i++)
            for(int j=m;j>=1;j--)
            {
                if(A[i-1]==B[j-1])
                    dp[j] = dp[j-1]+1;   
                else
                    dp[j]=0;
                ret = max(ret, dp[j]);
           }
        return ret;
    }
};
```

O(1)
```c++
class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
        int ret=0;
        int dp=0;
        for(int row=0;row<=n;row++)
        {
            dp = 0;
            for(int i=row,j=0;i<=n && j<=m;i++,j++)
            {
                if(A[i-1]==B[j-1])
                    dp+=1;
                else
                    dp=0;
                ret = max(ret, dp);
            }
        }
            
        for(int col=0;col<=m;col++)
        {
            dp = 0;
            for(int i=1,j=col;i<=n && j<=m;i++,j++)
            {
                if(A[i-1]==B[j-1])
                    dp+=1;
                else
                    dp=0;
                ret = max(ret, dp);
            }
        }
        return ret;
    }
};
```

## 最长上升子序列
> LeetCode/[最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/)

- dp[i]记录[0, i]的包含nums[i]的最长上升子序列
  - dp[i] = max{dp[j]+1, dp[i]} if nums[i] > nums[j] && j < i
  - 因此需要另外设置ret变量记录全局最长上升子序列
  - dp[0] = 1;
```c++
O(N^2)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // if(nums.empty()) return 0;
        int n = nums.size();
        vector<int> dp(n, 1);
        int ret = 0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<i;j++)
                if(nums[i]>nums[j])
                    dp[i] = max(dp[j]+1, dp[i]);
            ret = max(dp[i], ret);
        }
        return ret;
    }
};


- dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数
- 当nums[i] > dp中任何值时，加入nums[i]
- 否则替换对应位置的dp[i]
O(NlogN)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp;
        for(int i=0;i<n;i++)
        {

            int lo = 0;
            int hi = dp.size()-1;
            while(lo <= hi)  // 查找第一个大于等于Key的值的位置
            {
                int mid = lo + (hi - lo)/2;
                int num = nums[i];
                if(dp[mid] >= num)
                {
                    if(mid==0 || nums[mid-1] < num) // 注意二分查找的越界问题
                    {
                        lo = mid;   break;
                    }
                    else
                        hi = mid - 1;
                }
                else 
                { 
                        lo = mid + 1; 
                }
            }

            if(lo == dp.size()) 
                dp.push_back(nums[i]);
            else  
                dp[lo] = nums[i];
            
        }
        return dp.size();
    }
};

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp;
        for(int i=0;i<n;i++)
        {
            int num = nums[i];
            auto item_lo = lower_bound(dp.begin(), dp.end(), num);
            
            if(item_lo == dp.end())
                dp.push_back(num);
            else
                *item_lo = num;
            
        }
        return dp.size();
    }
};
```
## 最长回文子序列
> LeetCode/[最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/submissions/)

> bilibili/[花花酱](https://www.bilibili.com/video/av31243440)

- 注意回文是分偶数或者奇数长度的
- dp[i][j]表示[i,j]的最长回文子序列
- 初始化要令为0，因为偶数长度的回文子序列的base case是0
- 而奇数长度的回文子序列，base case是长度为1的子序列，对应大小为1
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        const int n = s.size();
        if(n==0) return 0;
        vector<vector<int> > dp(n, vector<int>(n, 0));
        
        for(int l=1;l<=n;l++) // 从长度开始遍历，逻辑更加清晰
            for(int i=0;i<(n-l+1);i++)
                {
                    int j = i+l-1;
                    if(i==j) {dp[i][j]=1; continue;}  //base case
                    else if(s[i]==s[j]) dp[i][j] = dp[i+1][j-1]+2;
                    else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
  
        return dp[0][n-1];
    }
};
```

O(N)优化
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        const int n = s.size();
        if(n==0) return 0;
        vector<int> dp0(n, 0); 
        vector<int> dp1(n, 0); // 长度比dp0小1
        vector<int> dp2(n, 0); // 长度比dp0小2
        
        for(int l=1;l<=n;l++)
        {
            for(int i=0;i<(n-l+1);i++)
                {
                    int j = i+l-1;
                    if(i==j) {dp0[i]=1; continue;}
                    else if(s[i]==s[j]) dp0[i] = dp2[i+1]+2;
                    else dp0[i] = max(dp1[i+1], dp1[i]);
                    
                }
            dp1.swap(dp2); //O(1)
            dp0.swap(dp1);
        }
            
        return dp1[0]; // 注意返回值
    }
};
```

## 最长回文子串
> LeetCode/[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/submissions/)

分析同上题，但注意转移方程条件变化了
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        const int n = s.size();
        if(n==0) return "";
        vector<vector<int> > dp(n, vector<int>(n, 0));
        int maxL = 0;
        string ret;
        for(int l=1;l<=n;l++) // 从长度开始遍历，逻辑更加清晰
            for(int i=0;i<(n-l+1);i++)
                {
                    int j = i+l-1;
                    if(i==j) 
                        dp[i][j]=1;   //base case
                    else if(s[i]==s[j]) 
                    {
                        if(l==2 || dp[i+1][j-1]!=0)
                            dp[i][j] = dp[i+1][j-1]+2;          
                    }
                    
                    if(dp[i][j]>maxL){
                        maxL=dp[i][j];
                        ret=s.substr(i,l);
                    }
                }
  
        return ret;
    }
};
```

## 最大连续子序列的和
> NowCoder/[最大连续子序列的和](https://www.nowcoder.com/questionTerminal/afe7c043f0644f60af98a0fba61af8e7)

- O(n)
- 前缀和大于0时，则连续子序列加上前缀和
- 否则前缀和归0，重新开始计算前缀和
- **感觉不能算动规的题**
```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <climits>

using namespace std;

void solution()
{
    int n;
    while(cin>>n && n)
    {
        vector<int> a(n);
        for (int i = 0; i<n; i++)
            cin >> a[i];
        int ret = INT_MIN; // 返回值
        int retBegin = 0;  // 返回的连续子序列初始值
        int retEnd = 0;  // 返回的连续子序列末值
        int cum = 0; // 前缀和（伪）
        int begin = a[0];  // 当前初始值
        int end = a[n-1];  // 当前末值
        for(int i=0;i<n;i++)
        {
            if(cum==0) begin = a[i];
            cum += a[i];
            end = a[i];
            
            if(cum > ret)
            {
                ret = cum;
                retBegin = begin;
                retEnd = end;
            }
            
            if(cum < 0) cum=0; 
        }
        if(ret < 0)
            cout<<"0 "<<a[0]<<" "<<a[n-1]<<endl;
        else
            cout<<ret<<" "<<retBegin<<" "<<retEnd<<endl;
    }
}

int main() {
    solution();
    return 0;
}
```

## 编辑距离
> LeetCode/[编辑距离](https://leetcode-cn.com/problems/edit-distance/submissions/)

**描述**
```
给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
示例 1:

输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```
- dp[i][j]表示长度为i的前缀转换到长度为j的前缀的最小操作数
- base case: dp[i][0] = i, dp[0][j] = j
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        for(int i=0;i<=n;i++)
            dp[i][0] = i;
        for(int j=0;j<=m;j++)
            dp[0][j] = j;
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
            {
                if(word1[i-1]==word2[j-1])
                {
                    dp[i][j]=dp[i-1][j-1];
                }
                else
                {
                    dp[i][j]=min(dp[i][j-1]+1, dp[i-1][j]+1);
                    dp[i][j]=min(dp[i-1][j-1]+1, dp[i][j]);
                }   
            }
        return dp[n][m];
    }
};
```
## 最大正方形
> LeetCode/[最大正方形](https://leetcode-cn.com/problems/maximal-square/)

**描述**
```
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```
- 思想:当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它[自己了。](https://blog.csdn.net/nk_test/article/details/48901853)
- dp[i][j]表示以m[i][j]为正方形右下角的最大正方形边长
  - 如果m[i][j]==0, 则dp[i][j]=0;
  - 否则m[i][j]==1, 则dp[i][j]=min{dp[i-1][j], dp[i][j-1], dp[i-1][j-1]};
- base case: dp[i][0] = m[i][0] - '0', dp[0][j] = m[0][j] - '0' （边界问题）
```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty())
            return 0;
        int n = matrix.size();
        int m = matrix[0].size();

        vector<vector<int>> dp(n, vector<int>(m, 0));
        int maxRet=0;
        for(int i=0;i<n;i++)
        {
            dp[i][0]=matrix[i][0]-'0';
            maxRet = max(maxRet, dp[i][0]);   // 防止maxRet返回0
        }
        for(int j=0;j<m;j++)
        {
            dp[0][j]=matrix[0][j]-'0';
            maxRet = max(maxRet, dp[0][j]);
        }
        for(int i=1;i<n;i++)
            for(int j=1;j<m;j++)
            {
                if(matrix[i][j]=='0')
                    dp[i][j]=0;
                else
                {
                    dp[i][j]=min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;
                    maxRet = max(maxRet, dp[i][j]);
                }
            }
        return maxRet*maxRet;
    }
};
  ```