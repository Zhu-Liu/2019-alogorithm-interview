目录
---
<!-- TOC -->

- [二叉树的深度](#二叉树的深度)
- [二叉树的宽度（求第K层的结点个数）](#二叉树的宽度求第k层的结点个数)
- [二叉树的层次遍历](#二叉树的层次遍历)
- [二叉树的最大宽度](#二叉树的最大宽度)
- [树的子结构](#树的子结构)
- [重建二叉树](#重建二叉树)
- [序列化二叉树](#序列化二叉树)
- [二叉树的最近公共祖先](#二叉树的最近公共祖先)
- [旋转链表](#旋转链表)
- [反转链表](#反转链表)
- [合并两个有序的链表](#合并两个有序的链表)
- [链表排序](#链表排序)
- [搜索二维矩阵](#搜索二维矩阵)
- [搜索二维矩阵II](#搜索二维矩阵ii)

<!-- /TOC -->
## 二叉树的深度
> NowCoder/[二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
```C++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot==NULL) return 0;
        return max(TreeDepth(pRoot->left), TreeDepth(pRoot->right)) + 1;
    }
};
```

```Python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def TreeDepth(self, pRoot):
        if pRoot == None:
            return 0
        return max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right))+1
        # write code here
```

## 二叉树的宽度（求第K层的结点个数）
> 该题未经过测试

- 层次遍历
```C++
class solution{
public:
    int widthOfBinaryTree(TreeNode* root)
    {
        if(root == NULL)return 0;
        queue<TreeNode*> Q;
        Q.push(root);

        int ans = 1;
        while(!Q.empty())
        {
            int c_size = Q.size();
            ans = max(c_size , ans); 
            for(int i = 0; i < c_size; i++) // 对每层的结点遍历
            {
                auto node = Q.front();
                Q.pop();
                if(node->left != NULL) Q.push(node->left);               
                if(node->right != NULL) Q.push(node->right);
            }
        }
        return ans;
    }
}
```
使用队列来完成任务，类似BFS。每一个循环步骤中将当前队列中节点的子节点入队列，该节点出队列。每个循环完统计当前队列长度即为该层宽度。

## 二叉树的层次遍历
> LeetCode/[二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/)

**描述**
```
给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。
```
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int> > ret;
        if(root == nullptr)
            return ret;
        queue<TreeNode*> q;
        q.push(root);
        vector<int> cur;
        while(!q.empty()){
            int c_size = q.size();
            for(int i = 0; i < c_size; i++){
                auto t = q.front();
                cur.push_back(t->val);
                q.pop();
                if(t->left != nullptr)
                    q.push(t->left);
                if(t->right != nullptr)
                    q.push(t->right);
            }
            ret.push_back(cur);
            cur.clear();
        }
        return ret;
    }
};
```

## 二叉树的最大宽度
> LeetCode/[二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/submissions/)

**描述**
```
示例 4:

输入: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
```
- 层次遍历
- 第n层都有2^(n-1)个节点, 左孩子标号为2n, 右孩子标号为2n+1, 根据标号得到当前层的长度。
- 使用stl中的queue和pair,注意deque是双向队列，用deque的话入队就是push_back
```C++
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if(root == nullptr)
            return 0;
        queue<pair<TreeNode*, unsigned int> > Q;
        Q.push(make_pair(root, 1));

        int ans = 1;
        while(!Q.empty())
        {
            int c_size = Q.size(); // 出队结点个数
            int temp_ans = Q.back().second - Q.front().second + 1; // 标号差即为当前层宽度
            ans = max(temp_ans, ans);
            for(int i = 0; i < c_size; i++)
            {
                auto node = Q.front();
                Q.pop();
                if(node.first->left != nullptr) 
                    Q.push(make_pair(node.first->left, node.second*2));
                if(node.first->right != nullptr) 
                    Q.push(make_pair(node.first->right, node.second*2+1));
            }
        }
        return ans;
    }
};
```

## 树的子结构
> NowCoder/[树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
```c++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1 == NULL || pRoot2 == NULL) return false;
        
        return IsSubtree(pRoot1, pRoot2) 
            || HasSubtree(pRoot1->left, pRoot2) 
            || HasSubtree(pRoot1->right, pRoot2);
    }
    
    bool IsSubtree(TreeNode* p1, TreeNode* p2)
    {
        if(p2 == NULL) return true;  //注意边界判断，当p2为空时，即为真子集
        if(p1 == NULL) return false;
        if(p1->val != p2->val)
            return false;
        else
            return IsSubtree(p1->left, p2->left) && IsSubtree(p1->right, p2->right);
    }
};
```

```Python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        if pRoot1 == None or pRoot2 == None:
            return False
        
        return self.IsSubtree(pRoot1, pRoot2) \   # Python换行要加对应的符号
                or self.HasSubtree(pRoot1.left, pRoot2) \
                or self.HasSubtree(pRoot1.right, pRoot2)
            
    def IsSubtree(self, p1, p2):
        if p2 == None: 
            return True
        if p1 == None: 
            return False
        if p1.val == p2.val:
            return self.IsSubtree(p1.left, p2.left) and self.IsSubtree(p1.right, p2.right)
        else:
            return False
```

## 重建二叉树
> NowCoder/[重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
```Python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        if len(pre) == 0:
            return None
        root = TreeNode(pre[0])
        index = tin.index(pre[0]) #用Python写非常直观
        root.left = self.reConstructBinaryTree(pre[1:1+index], tin[:index])
        root.right = self.reConstructBinaryTree(pre[1+index:], tin[1+index:])
        return root
```

```c++

```

## 序列化二叉树
> NowCoder/[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
    stringstream ss_serial;
    stringstream ss_deserial;
public:
    char* Serialize(TreeNode *root) {    
        dfs_serial(root);
        char result[1024];
        // str()用来取出字符串，c_str()用来转换成const* char;
        return strcpy(result, ss_serial.str().c_str());
    }
    
    void dfs_serial(TreeNode *root)
    {
        // 中序遍历
        if(root == nullptr) {ss_serial << "#"; return;}
        ss_serial << root->val ;
        ss_serial << ",";
        dfs_serial(root->left);
        ss_serial << ",";
        dfs_serial(root->right);
    }
    
    TreeNode* Deserialize(char *str) {
        if(strlen(str) < 1) return nullptr;
        
        ss_deserial << str;
        return dfs_deserial();    
    }
    
    TreeNode* dfs_deserial(){
        if(ss_deserial.eof()) return nullptr;
        
        string val;
        getline(ss_deserial, val, ',');

        if(val == "#") return nullptr;
        else
        {
            // stoi从字符转换成整数
            TreeNode* node = new TreeNode{ stoi(val) };
            node->left = dfs_deserial();
            node->right = dfs_deserial();
            return node;
        }
        
    }
};
```

## 二叉树的最近公共祖先
> LeetCode/[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/comments/)
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    bool foundPath(TreeNode* root, TreeNode* p, deque<TreeNode*>& path)
    {

        if(root == nullptr) return false;
        
        path.push_back(root);
        
         bool found = false;
        if(p == root) found = true;
        
       
        if(!found)
            found = foundPath(root->left, p, path);
        
        if(!found)
            found = foundPath(root->right, p, path);
            
        if(!found)
            path.pop_back();

        return found;

    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        deque<TreeNode*> path_p;
        auto found_p = foundPath(root, p, path_p);
        deque<TreeNode*> path_q;
        auto found_q = foundPath(root, q, path_q);
        
        TreeNode* lastNode = NULL;
        if(found_p && found_q)
        {
            auto it_p = path_p.begin();
            auto it_q = path_q.begin();
            while(it_p != path_p.end() && it_q != path_q.end())
            {
                if(*it_p == *it_q) lastNode = *it_q;
                
                it_p++;
                it_q++;

            }
        }

        return lastNode;
};
```

## 旋转链表
> LeetCode/[旋转链表](https://leetcode-cn.com/problems/rotate-list/submissions/)
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head == nullptr || k <=0) return head;
        
        int length = 1;
        ListNode* tail = head;
        ListNode* head_constant = head;
        ListNode* head_new = nullptr;
        while(tail->next != nullptr)
        {
            length++;
            tail = tail->next;
        }
        
        k = length - (k % length) - 1; // 倒数第K个节点
        
        while(k>0)
        {
            k--;
            head = head->next;
        }
        
        
        tail->next = head_constant;
        head_new = head->next;
        head->next = nullptr;  // 注意顺序，避免【1】 1的情况
        
        return head_new;
    }
};
```


## 反转链表
> NowCoder/[反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

**描述**
```
输入一个链表，反转链表后，输出新链表的表头。
```
```C++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
         if(pHead == nullptr) return pHead;
         ListNode* pre = nullptr;  //注意从空指针开始，考虑只有1个节点的情况
         ListNode* cur = pHead;
         ListNode* nex = cur->next;
         cur->next = nullptr;
         while(nex != nullptr)
         {
             pre = cur;
             cur = nex;
             nex = nex->next;
             cur->next = pre;
         }
         return cur;
    }
};
```

## 合并两个有序的链表
> NowCoder/[合并两个有序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        
        if(pHead1->val < pHead2->val)
        {
            pHead1->next = Merge(pHead1->next, pHead2);
            return pHead1;
        }
        else
        {
            pHead2->next = Merge(pHead1, pHead2->next);
            return pHead2;
        }
    }
};
```

## 链表排序
> LeetCode/[链表排序](https://leetcode-cn.com/problems/sort-list/comments/)
- 快排
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    void qsort(ListNode* lo, ListNode* hi) //  [lo, hi)
    {
        if(lo==hi || lo->next ==hi) //快排注意边界判断
            return;
        
        ListNode* mid = lo;
        int key = lo->val;
        for(auto i=lo->next;i!=hi;i=i->next)
        {
            if(i->val < key)
            {
                mid = mid->next;
                swap(i->val, mid->val);
            }
        }
        swap(mid->val, lo->val);
            
        qsort(lo, mid);
        qsort(mid->next, hi);
    }
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        
        qsort(head, nullptr); //直接传空指针
        return head;
    }
};
```
- 归并
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    ListNode* mergeSort(ListNode* l1, ListNode* l2)
    {
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;
        
        ListNode* l;
        if(l1->val < l2->val)
        {
            l = l1;
            l1 = l1->next;
        }
        else
        {
            l = l2;
            l2 = l2->next;
        }
        ListNode* p = l;
        while(l1 && l2)
        {
            
            if(l1->val < l2->val)
            {
                p->next = l1;
                p = p->next;
                l1 = l1->next;
            }
            else
            {
                p->next = l2;
                p = p->next;
                l2 = l2->next;
            }
        }
        
        if(l1) p->next = l1; //最后没排序到的直接接上
        if(l2) p->next = l2;
        
        return l;
    }

public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        auto s = head;
        auto f = head;
        
        while(f->next && f->next->next) //双指针判断中间位置
        {
            f = f->next->next;
            s = s->next;
        }
        
        f = s->next; // s即为mid
        s->next = nullptr;
        f = sortList(f);
        head = sortList(head); //注意是返回的是头指针
        return mergeSort(f,head);
    }

};
```

## 缺失的第一个正数
> LeetCode/[缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

**描述**
```
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
```
- 哈希，利用数组下标作为key, 存放值为key+1
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        
        for(int i = 0; i < nums.size(); i++){
            while(nums[i] - 1 >= 0 && nums[i] - 1 < nums.size() && nums[nums[i] - 1] != nums[i])
                swap(nums[i], nums[nums[i] - 1]); // 交换，知道i放的数字为i+1或者不合法数字（0，负数或者大整数）
        }
        
        for(int i = 0; i < nums.size(); i++)
            if(nums[i] != i + 1)
                return i + 1;
                
        return nums.size() + 1; // 如果每一个位置都放上了对应的正整数【1，n】, 则返回 n + 1
    }
};
```

- 快排，

## 搜索二维矩阵
> LeetCode/[搜索二维矩阵I]（https://leetcode-cn.com/problems/search-a-2d-matrix/description/）
```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        if(matrix.size() < 1 || matrix[0].size() < 1) return false;
        
        int m = matrix.size();
        int n = matrix[0].size();
            
        int lo = 0;
        int hi = m*n - 1;
        
        while(lo < hi)
        {
            int mid = (lo + hi) / 2; // 不知道为什么不能用位运算
            if(matrix[mid / n][mid % n] == target)  {lo = mid; break;}
            else if(matrix[mid / n][mid % n] < target) lo = mid + 1;
            else hi = mid - 1;
        }
        
        return matrix[lo / n][lo % n] == target;
        /*
        while(lo <= hi)
        {
            int mid = (lo + hi) / 2; // 不知道为什么不能用位运算
            if(matrix[mid / n][mid % n] == target)  return true;
            else if(matrix[mid / n][mid % n] < target) lo = mid + 1;
            else hi = mid - 1;
        }
        
        return false;
        */
    }
};

```

## 搜索二维矩阵II
> LeetCode/[搜索二维矩阵II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/submissions/)
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.size() < 1 || matrix[0].size() < 1) return false;
        
        int row = 0 ;
        int column = matrix[0].size() - 1;
        
        while(row < matrix.size() && column >= 0)
        {
            if(matrix[row][column] == target) return true;
            else if(matrix[row][column] < target) row++;
            else column--;
        }
        
        return false;
    }
};
```
