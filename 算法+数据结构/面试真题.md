## 一个数组中只有0和1，求0和1个数相等的最长连续子序列
> 知乎/[百度面试题](https://www.zhihu.com/question/25526488?sort=created)
**题解**
```
暴力求解法的复杂度为O(N^2), 实际存在O(N)的解法。
首先转换题意，令数组中的0为-1，因而问题转变为一个数组中只有-1和1，求和为0的最长连续子序列。
问题因此又可转换为求前缀和`max(j - i), s.t. sum[i]=sum[j]`
```
```c++
#include <vector>
#include <iostream>
using namespace std;
int main(){
    vector<int> array = {0, 1, 1, 0, 1};
    int counts = array.size();
    vector<int> sum;
    sum.reserve(counts + 1);
    sum.push_back(0);
    for(const auto& x : array){
        sum.push_back(sum.back() + x*2 - 1);
    }

    vector<int> temp(2 * counts + 1, -1);
    int start = -1;
    int end = -1;
    int retLen = -1;
    for(int i = 0; i < counts; i++){
        int index = counts + sum[i];
        if(temp[index] == -1){
            temp[index] = i;
        }
        else{
            int tempLen = i - temp[index];
            if(tempLen > retLen){
                start = temp[index];
                end = i;
                retLen = tempLen ;
            }
        }
    }

    if(retLen != -1)
        cout<<start<<" "<<end<<" "<<retLen<<endl;
    else
        cout<<"NOT EXIST"<<endl;
}
```

## 给一个字符串，得到它字典序最大的子序列
- 注意前缀相同的字符串，越长则字典序越大
- 用栈保存每个字符，每次比较，如果小则入栈，大则将栈中元素弹出
```c++
string str = "ababba";
deque<char> s; ## 用双端队列方便逆序输出
for(int i = 0; i < str.size(); i++){
    while(!s.empty() && s.back() < str[i]) s.pop_back();
    s.push_back(str[i]);
}
for(auto i : s)
    cout<<i;
```

## 24点(给一串数和一个目标值，使用四则运算和括号使得这串数最后计算结果为目标值)
- 暴力搜索
```c++
class Solution {
    double epsilon = pow(10.0, -5);
    vector<char> oper = {'+', '-', '*', '/'};
public:
    bool judgePoint24(vector<int>& nums) {
        vector<double> vec;
        for(auto n : nums)
            vec.push_back(n*1.0); // 转换成double
        return find24(vec);
    }
    
    bool find24(vector<double> vec){
        int n = vec.size();
        if(n == 1)
            return abs(vec[0] - 24.0) <= epsilon;
        
        
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++){ // 取出两个数字
                if(i == j) continue;
                vector<double> res;
                for(int k = 0; k < n; k++){
                    if(k != i && k != j)
                        res.push_back(vec[k]);
                }
                
                for(auto op : oper){
                    if( (op == '+' || op == '*') && i > j) continue; // + 和 * 左右数字交换对结果没有影响
                    if( op == '/' && vec[j] == 0.0) continue;
                    switch(op){
                        case '+': res.push_back(vec[i] + vec[j]); break; // 注意 break;
                        case '-': res.push_back(vec[i] - vec[j]); break;
                        case '*': res.push_back(vec[i] * vec[j]); break;
                        case '/': res.push_back(vec[i] / vec[j]); break;
                    }
                    if(find24(res)) return true;
                    res.pop_back();
                }
            }
        return false;
    }
};
```