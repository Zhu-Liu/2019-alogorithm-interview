1、[零钱兑换I](https://leetcode-cn.com/problems/coin-change/description/)
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int INF = amount + 1;
        vector<int> dp(amount+1, INF);
        
        dp[0] = 0;
        
        for(auto c : coins)
            for(int i=c;i<=amount;i++)
                dp[i] = min(dp[i], dp[i-c] + 1);
        
        return dp[amount] < INF ? dp[amount] : -1;
    }
};
```

2、[零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        if(amount<0) return 0;

        vector<int> dp(amount+1, 0);
        dp[0]=1;
        for(auto i: coins)
            for(int j=i;j<=amount;j++)
                    dp[j] += dp[j-i];
        
        return dp[amount];
    }
};
```

3、[最长公共子序列](https://www.nowcoder.com/questionTerminal/c996bbb77dd447d681ec6907ccfb488a)
```c++
class LCS {
public:
    int findLCS(string A, int n, string B, int m) {
        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1; //注意下标
                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        return dp[n][m];
    }
};
```

4、[最长公共子串](https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602)
```c++
class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        int ret=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                if(A[i-1]==B[j-1])
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                    ret = max(ret, dp[i][j]);
                }
        return ret;
    }
};
```

空间复杂度优化成O（N）
```c++
class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
        vector<int>dp(m+1, 0);
        int ret=0;
        for(int i=1;i<=n;i++)
            for(int j=m;j>=1;j--)
            {
                if(A[i-1]==B[j-1])
                    dp[j] = dp[j-1]+1;   
                else
                    dp[j]=0;
                ret = max(ret, dp[j]);
           }
        return ret;
    }
};
```

O(1)
```c++
class LongestSubstring {
public:
    int findLongest(string A, int n, string B, int m) {
        int ret=0;
        int dp=0;
        for(int row=0;row<=n;row++)
        {
            dp = 0;
            for(int i=row,j=0;i<=n && j<=m;i++,j++)
            {
                if(A[i-1]==B[j-1])
                    dp+=1;
                else
                    dp=0;
                ret = max(ret, dp);
            }
        }
            
        for(int col=0;col<=m;col++)
        {
            dp = 0;
            for(int i=1,j=col;i<=n && j<=m;i++,j++)
            {
                if(A[i-1]==B[j-1])
                    dp+=1;
                else
                    dp=0;
                ret = max(ret, dp);
            }
        }
        return ret;
    }
};
```

5、[最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/)
```c++
O(N^2)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // if(nums.empty()) return 0;
        int n = nums.size();
        vector<int> dp(n, 1);
        int ret = 0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<i;j++)
                if(nums[i]>nums[j])
                    dp[i] = max(dp[j]+1, dp[i]);
            ret = max(dp[i], ret);
        }
        return ret;
    }
};

O(NlogN)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp;
        for(int i=0;i<n;i++)
        {

            int lo = 0;
            int hi = dp.size()-1;
            while(lo <= hi)  //查找第一个大于等于Key的值的位置
            {
                int mid = lo + (hi - lo)/2;
                int num = nums[i];
                if(dp[mid] >= num)
                {
                    if(mid==0 || nums[mid-1] < num)
                    {
                        lo = mid;   break;
                    }
                    else
                        hi = mid - 1;
                }
                else 
                { 
                        lo = mid + 1; 
                }
            }

            if(lo == dp.size()) 
                dp.push_back(nums[i]);
            else  
                dp[lo] = nums[i];
            
        }
        return dp.size();
    }
};

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp;
        for(int i=0;i<n;i++)
        {
            int num = nums[i];
            auto item_lo = lower_bound(dp.begin(), dp.end(), num);
            
            if(item_lo == dp.end())
                dp.push_back(num);
            else
                *item_lo = num;
            
        }
        return dp.size();
    }
};
```

6、[最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/submissions/)
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        const int n = s.size();
        if(n==0) return 0;
        vector<vector<int> > dp(n, vector<int>(n, 0));
        
        for(int l=1;l<=n;l++) // 从长度开始遍历，逻辑更加清晰
            for(int i=0;i<(n-l+1);i++)
                {
                    int j = i+l-1;
                    if(i==j) {dp[i][j]=1; continue;}  //base case
                    else if(s[i]==s[j]) dp[i][j] = dp[i+1][j-1]+2;
                    else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
  
        return dp[0][n-1];
    }
};
```

O(N)优化
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        const int n = s.size();
        if(n==0) return 0;
        vector<int> dp0(n, 0);
        vector<int> dp1(n, 0);
        vector<int> dp2(n, 0);
        
        for(int l=1;l<=n;l++)
        {
            for(int i=0;i<(n-l+1);i++)
                {
                    int j = i+l-1;
                    if(i==j) {dp0[i]=1; continue;}
                    else if(s[i]==s[j]) dp0[i] = dp2[i+1]+2;
                    else dp0[i] = max(dp1[i+1], dp1[i]);
                    
                }
            dp1.swap(dp2); //O(1)
            dp0.swap(dp1);
        }
            
        return dp1[0];
    }
};
```
参考：[花花酱Leetcode](https://www.bilibili.com/video/av31243440)  

7、LeetCode 5[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/submissions/)
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        const int n = s.size();
        if(n==0) return "";
        vector<vector<int> > dp(n, vector<int>(n, 0));
        int maxL = 0;
        string ret;
        for(int l=1;l<=n;l++) // 从长度开始遍历，逻辑更加清晰
            for(int i=0;i<(n-l+1);i++)
                {
                    int j = i+l-1;
                    if(i==j) 
                        dp[i][j]=1;   //base case
                    else if(s[i]==s[j]) 
                    {
                        if(l==2 || dp[i+1][j-1]!=0)
                            dp[i][j] = dp[i+1][j-1]+2;          
                    }
                    
                    if(dp[i][j]>maxL){
                        maxL=dp[i][j];
                        ret=s.substr(i,l);
                    }
                }
  
        return ret;
    }
};
```


** 感觉不能算动规的题
牛客网：[最大连续子序列的和](https://www.nowcoder.com/questionTerminal/afe7c043f0644f60af98a0fba61af8e7)
```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <climits>

using namespace std;

void solution()
{
    int n;
    while(cin>>n && n)
    {
        vector<int> a(n);
        for (int i = 0; i<n; i++)
            cin >> a[i];
        int ret = INT_MIN;
        int retBegin = 0;
        int retEnd = 0;
        int cum = 0;
        int begin = a[0];
        int end = a[n-1];
        for(int i=0;i<n;i++)
        {
            if(cum==0) begin = a[i];
            cum += a[i];
            end = a[i];
            
            if(cum > ret)
            {
                ret = cum;
                retBegin = begin;
                retEnd = end;
            }
            
            if(cum < 0) cum=0; 
        }
        if(ret < 0)
            cout<<"0 "<<a[0]<<" "<<a[n-1]<<endl;
        else
            cout<<ret<<" "<<retBegin<<" "<<retEnd<<endl;
    }
}

int main() {
    solution();
    return 0;
}
```

8、[编辑距离](https://leetcode-cn.com/problems/edit-distance/submissions/)
```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();
        
        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        for(int i=0;i<=n;i++)
            dp[i][0] = i;
        for(int j=0;j<=m;j++)
            dp[0][j] = j;
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
            {
                if(word1[i-1]==word2[j-1])
                {
                    dp[i][j]=dp[i-1][j-1];
                }
                else
                {
                    dp[i][j]=min(dp[i][j-1]+1, dp[i-1][j]+1);
                    dp[i][j]=min(dp[i-1][j-1]+1, dp[i][j]);
                }   
            }
        return dp[n][m];
    }
};

9、[最大正方形](https://leetcode-cn.com/problems/maximal-square/)
  当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它[自己了。](https://blog.csdn.net/nk_test/article/details/48901853)
  ```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty())
            return 0;
        int n = matrix.size();
        int m = matrix[0].size();

        vector<vector<int>> dp(n, vector<int>(m, 0));
        int maxRet=0;
        for(int i=0;i<n;i++)
        {
            dp[i][0]=matrix[i][0]-'0';
            maxRet = max(maxRet, dp[i][0]);   
        }
        for(int j=0;j<m;j++)
        {
            dp[0][j]=matrix[0][j]-'0';
            maxRet = max(maxRet, dp[0][j]);
        }
        for(int i=1;i<n;i++)
            for(int j=1;j<m;j++)
            {
                if(matrix[i][j]=='0')
                    dp[i][j]=0;
                else
                {
                    dp[i][j]=min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;
                    maxRet = max(maxRet, dp[i][j]);
                }
            }
        return maxRet*maxRet;
    }
};
  ```