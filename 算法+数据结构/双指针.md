1、[两数之和](https://leetcode-cn.com/problems/two-sum/submissions/)
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        unordered_map<int, int>m;
        vector<int> result;
        for(auto i=0;i<numbers.size();i++)
        {
            if(m.find(numbers[i]) == m.end())
                m[target-numbers[i]] = i;
            else
            {
                result.push_back(i+1);
                result.push_back(m[numbers[i]]+1);   
            }
        }
        sort(result.begin(), result.end());
        return result;
    }
};
``

2、[两数之和II](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/submissions/)
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int lo = 0;
        int hi = numbers.size()-1;
        vector<int> result;
        while(lo<=hi)
        {   
            if( (numbers[lo]+numbers[hi]) == target ) break;
            else if( (numbers[lo]+numbers[hi]) > target ) hi--;
            else lo++;
        }
        result.push_back(lo+1);
        result.push_back(hi+1);
        return result;
    }
};
```

3、[三数之和](https://leetcode-cn.com/problems/3sum/)
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int> > result;
        
        if(nums.size() == 0) return result;
        
        sort(nums.begin(), nums.end()); //sort nums 先排序
        
        for(int i=0;i<nums.size()-2 && nums[i]<=0; i++) // 注意判重
        {
            if(i>0 && nums[i] == nums[i-1]) continue;
            
            int l = i + 1, r = nums.size()-1;
            while(l<r)
            {
                if(nums[i] + nums[l] + nums[r] == 0)
                {
                    result.push_back({nums[i], nums[l], nums[r]});
                    
                    while(++l<r && nums[l] == nums[l-1]);
                    while(--r>l && nums[r] == nums[r+1]);
                }
                else if(nums[i] + nums[l] + nums[r] < 0)
                    l++;
                else
                    r--;
            }
        }
        
        return result;
    }
};
```

4、[四数之和](https://leetcode-cn.com/problems/4sum/submissions/)
```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        if(nums.size()<4) return result;
        
        //排序
        sort(nums.begin(), nums.end());
        
        for(int i=0;i<nums.size()-3;i++)
        {
            if(i && nums[i]==nums[i-1])continue;
            
            for(int j=i+1;j<nums.size()-2;j++)
            {
                if(j>i+1 && nums[j]==nums[j-1])continue;
                int sum = target - nums[i] -nums[j];
                int l=j+1, r=nums.size()-1;
                while(l < r)
                {
                    if(nums[l] + nums[r] == sum)
                    {
                        //cout<<nums[i]<<" "<<nums[j]<<" "<<nums[l]<<" "<<nums[r]<<" ";
                        result.push_back({nums[i],nums[j],nums[l],nums[r]});
                        while(++l<r && nums[l] == nums[l-1]);
                        while(l<--r && nums[r] == nums[r+1]);
                    }
                    else if(nums[l] + nums[r] < sum)
                        l++;
                    else
                        r--;
                }
            }
            
        }

        return result;
    }
};
```

5、[最接近的三数之和](https://leetcode-cn.com/problems/4sum/submissions/)
```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        
        //if(nums.size() == 0) return result;
        
        sort(nums.begin(), nums.end()); //sort nums
        
        int result = nums[0] + nums[1] + nums[2];
        
        for(int i=0;i<nums.size()-2; i++)
        {
            if(i>0 && nums[i] == nums[i-1]) continue;
            
            int l = i + 1, r = nums.size()-1;
            while(l<r)
            {
                int temp = nums[i] + nums[l] + nums[r];
                result = abs(target - temp) < abs(target - result) ? temp : result;
                if(nums[i] + nums[l] + nums[r] <= target)
                    l++;
                else
                    r--;
            }
        }
        
        return result;
    }
};
```

6、[三数之和，小于目标值的个数](https://www.lintcode.com/problem/3sum-smaller/description)
```c++
class Solution {
public:
    /**
     * @param nums:  an array of n integers
     * @param target: a target
     * @return: the number of index triplets satisfy the condition nums[i] + nums[j] + nums[k] < target
     */
    int threeSumSmaller(vector<int> &nums, int target) {
        //vector<vector<int> > result;
        if (nums.size()<3) return 0;
        int ret=0;
        
        sort(nums.begin(), nums.end()); //sort nums 先排序
  
        for(int i=0;i<nums.size()-2; i++) // 不能使用条件nums[i]<=target，因为会多个负数相加会更小
        {
            int l = i + 1, r = nums.size()-1;
            while(l<r)
            {
                if(nums[i] + nums[l] + nums[r] < target)
                    {
                        cout<<nums[i]<<" "<<ret<<endl;
                        ret+=(r-l);
                        l++;
                    }
                else
                    r--;
            }
        }
        
        return ret;   
    }
};
```

7、[有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/submissions/)
```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size();
        int ret = 0;
        if(n<3) return ret;
        
        sort(nums.begin(),nums.end());
        
        for(int i=nums.size()-1;i>1;i--)
        {
            int l=0,r=i-1;
            while(l<r)
            {
                if(nums[l]+nums[r] > nums[i])
                {
                    ret+=r-l;
                    r--;
                }
                else
                    l++;
            }
        }   
        
        return ret;
    }
};
```

8、[接雨水](https://leetcode-cn.com/problems/trapping-rain-water/submissions/)
```c++
每个点位所能接到的水=左右两边最高位置的较小值-当前高度
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if(n<=2) return 0;
        
        int ret=0;
        vector<int> L_max(height);
        vector<int> R_max(height);
        
        for(int i=1;i<n;i++)
            L_max[i] = max(L_max[i-1], height[i]);
        for(int i=n-2;i>=0;i--)
            R_max[i] = max(R_max[i+1], height[i]);
        
        for(int i=0;i<n;i++)
        {
            if(R_max[i]>height[i] && L_max[i]>height[i])
                ret+=min(R_max[i], L_max[i]) - height[i];
        }
        return ret;  
    }
};
```

9、[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int maxArea = 0;
        int area = 0;
        maxArea = (right - left) * min(height[left], height[right]);
        while(right > left)
        {
            height[left] < height[right] ? left++ : right-- ;
            area = (right - left) * min(height[left], height[right]);
            maxArea = maxArea > area ? maxArea : area;
        }
        return maxArea;   
    }
};
```

10、[反转字符串](https://leetcode-cn.com/problems/reverse-string/submissions/)
```c++  
class Solution {
public:
    string reverseString(string s) {
        reverse(s.begin(), s.end());//直接用reverse
        return s;
    }
};

class Solution {
public:
    string reverseString(string s) {
        string tempS="";
            
        for(int i=s.size()-1;i>=0;i--) //当然也可以定义l和r然后左右互换
            tempS+=s[i];
        return tempS;
    }
};
```

11、[颜色分类](https://leetcode-cn.com/problems/sort-colors/submissions/)
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        if(n<=0) return;
        int i=0, l=0, r=n-1;
        
        while(i<=r)
        {
            if(nums[i]==0)
            {
                swap(nums[i],nums[l]);
                l++;
            }
            else if(nums[i]==2)
            {
                swap(nums[i],nums[r]);
                r--;
                i--;
            }
            i++;
        }
    }
};
```

12、[数组中最长的山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/submissions/)
```c++
class Solution {
public:
    int longestMountain(vector<int>& A) {
        int n = A.size();
        if(n<=2) return 0;
        int maxRet = 0;
        for(int i=1;i<n-1;i++)
            if(A[i-1]<A[i] && A[i+1]<A[i])
            {   
                int l=i-1,r=i+1;
                while(l!=0 && A[l-1]<A[l] )l--;
                while(r!=(n-1) && A[r+1]<A[r]) r++;
                maxRet = max(maxRet, r-l+1);
            }

        return maxRet;
    }
};
```

13、[最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/submissions/)
```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> map;
        for(int i=0;i<t.size();i++)  //建立一个t字符串中字符的哈希表
            map[t[i]]= map.find(t[i])==map.end() ? 1 : map[t[i]]+1;
        
        int left=0,right=0;
        int minRet=INT_MAX;
        int minLeft=0, minRight=0;
        int count=0; // count用来统计所有的字符是否都统计到了
        
        while(right<s.size())
        {
            if(map.find(s[right])!=map.end())
            {
                // 注意这里的trick, 重复出现的字符不重复统计，同时右扩时根据对应的哈希值判断是否减少count
                if(map[s[right]]>0) count++; 
                map[s[right]]--;
            }
            
            while(count==t.size())
            {
                if( minRet > (right-left+1) )
                {
                    minRet = right-left+1;
                    minLeft = left;
                    minRight = right;
                }
                    
                if( map.find(s[left])!=map.end() )
                {
                    if(map[s[left]]>=0) count--; 
                    map[s[left]]++;
                }
                left++;
            }
                       
            right++;
        }
                       
        return minRet==INT_MAX ? "" : s.substr(minLeft, minRet);
    }
};
```

14、[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n=nums.size();
        int l=0,r=0;
        int minRet=INT_MAX;
        int tempSum=0;
        while(r<n)
        {
            tempSum+=nums[r];
            while(tempSum>=s)
            {
                minRet = min(minRet, r-l+1);
                tempSum-=nums[l];
                l++;
            }
            r++;
        }
        return minRet==INT_MAX ? 0:minRet;
    }       
};
```

15、[无重复字符的最长字串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/submissions/)
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> m;
        int max_length=0;
        int l=0;
        for(int r=0;r<s.size();r++)
        {
            if(m.find(s[r])!=m.end() && l<(m[s[r]]+1))
                l = m[s[r]]+1;
            max_length = max(max_length, r-l+1);
            m[s[r]] = r;
        }
        return max_length;
    }
};
```

16、[水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/submissions/)
```c++
class Solution {
public:
    int totalFruit(vector<int>& tree) {
        deque<int> q;
        unordered_map<int, int> m;
        int l=0;
        int maxRet=0;
        for(int r=0;r<tree.size();r++)
        {
            if(q.size()==0)
           {
                q.push_back(tree[r]);
           }
            else if(q.size()==1 && q.front()!=tree[r])
            {
                q.push_back(tree[r]);
            }
            else if(q.size()==2 && (q.front()!=tree[r] && q.back()!=tree[r] ) )
            {
                l = m[q.front()] < m[q.back()] ? m[q.front()]+1 : m[q.back()]+1;
                if(m[q.front()] < m[q.back()])
                    q.pop_front();
                else
                    q.pop_back();
                q.push_back(tree[r]);       
            }
            maxRet=max(maxRet, r-l+1);
            m[tree[r]]=r;
        }
        return maxRet;
    }
};
```

```c++
class Solution {
public:
    int totalFruit(vector<int>& tree) {
        deque<int> q;
        deque<int>::iterator pos;
        unordered_map<int, int> m;
        int l=0;
        int maxRet=0;
        for(int r=0;r<tree.size();r++)
        {
            pos = find(q.begin(),q.end(),tree[r]);
      
            if(pos!=q.end())
            {
                if(q.front()==tree[r])
                {
                    q.pop_front();
                    q.push_back(tree[r]);
                }
            }
           else if(q.size()<2 && pos==q.end())
           {
                q.push_back(tree[r]);
           }
            else if(q.size()==2 && pos==q.end() )
            {
                l = m[q.front()]+1;
                q.pop_front();
                q.push_back(tree[r]);       
            }
            maxRet=max(maxRet, r-l+1);
            m[tree[r]]=r;
            //cout<<l<<" "<<r<<endl;
        }
        return maxRet;
    }
};
```