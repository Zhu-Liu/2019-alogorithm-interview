1、[二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
```C++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot==NULL) return 0;
        return max(TreeDepth(pRoot->left), TreeDepth(pRoot->right)) + 1;
    }
};
```

```Python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def TreeDepth(self, pRoot):
        if pRoot == None:
            return 0
        return max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right))+1
        # write code here
```

2、二叉树的宽度
> 该题未经过测试
```C++
class solution{
public:
    int widthOfBinaryTree(TreeNode* root)
    {
        if(root == NULL)return 0;
        queue<TreeNode*> Q;
        Q.push(root);

        int ans = 1;
        while(!Q.empty())
        {
            int c_size = Q.size();
            ans = c_size>ans?c_size:ans;
            for(int i=0;i<c_size;i++)
            {
                auto node = Q.front();
                Q.pop();
                if(node->left != NULL) Q.push(node->left);               
                if(node->right != NULL) Q.push(node->right);
            }
        }
        return ans;
    }
}
```
使用队列来完成任务，类似BFS。每一个循环步骤中将当前队列中节点的子节点入队列，该节点出队列。每个循环完统计当前队列长度即为该层宽度。

3、[二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/submissions/)
每层都有2^(n-1)个节点,左孩子标号为2n,右孩子标号为2n+1,根据标号得到当前层的长度。
使用stl中的queue和pair,注意deque是双向队列，用deque的话入队就是push_back
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if(root == NULL)return 0;
        queue<pair<TreeNode*,int>> Q;
        Q.push(make_pair(root, 1));

        int ans = 1;
        while(!Q.empty())
        {
            int c_size=Q.size();
            int temp_ans = Q.back().second - Q.front().second + 1;
            ans = temp_ans>ans?temp_ans:ans;
            for(int i=0;i<c_size;i++)
            {
                auto node = Q.front();
                Q.pop();
                if(node.first->left != NULL) 
                    Q.push(make_pair(node.first->left, node.second*2));
                if(node.first->right != NULL) 
                    Q.push(make_pair(node.first->right, node.second*2+1));
            }
        }
        return ans;
    }
};
```
